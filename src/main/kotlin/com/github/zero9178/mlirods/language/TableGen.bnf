{
  parserClass="com.github.zero9178.mlirods.language.generated.TableGenParser"

  extends="com.intellij.extapi.psi.ASTWrapperPsiElement"

  psiClassPrefix="TableGen"
  psiImplClassSuffix="Impl"
  psiPackage="com.github.zero9178.mlirods.language.generated.psi"
  psiImplPackage="com.github.zero9178.mlirods.language.generated.psi.impl"
  psiImplUtilClass="com.github.zero9178.mlirods.language.psi.impl.TableGenPsiImplUtil"

  generate=[exact-types="all"]
  elementTypeHolderClass="com.github.zero9178.mlirods.language.generated.TableGenTypes"
  elementTypeClass="com.github.zero9178.mlirods.language.TableGenElementType"
  tokenTypeClass="com.github.zero9178.mlirods.language.TableGenTokenType"
  tokens = [
    PLUS='+'
    MINUS='-'
    LBRACKET='['
    RBRACKET=']'
    LBRACE='{'
    RBRACE='}'
    LANGLE='<'
    RANGLE='>'
    LPAREN='('
    RPAREN=')'
    COMMA=','
    COLON=':'
    SEMICOLON=';'
    DOT='.'
    ELLIPSE='...'
    EQUALS='='
    QUESTION_MARK='?'
    HASHTAG='#'
    ASSERT='assert'
    BIT='bit'
    BITS='bits'
    CLASS='class'
    CODE='code'
    DAG='dag'
    DEF='def'
    DUMP='dump'
    ELSE='else'
    FALSE='false'
    FOREACH='foreach'
    DEFM='defm'
    DEFSET='defset'
    DEFTYPE='deftype'
    DEFVAR='defvar'
    FIELD='field'
    IF='if'
    IN='in'
    INCLUDE='include'
    INT='int'
    LET='let'
    LIST='list'
    MULTICLASS='multiclass'
    STRING='string'
    THEN='then'
    TRUE='true'
    HASHTAG_DEFINE='#define'
    HASHTAG_IFDEF='#ifdef'
    HASHTAG_IFNDEF='#ifndef'
    HASHTAG_ELSE='#else'
    HASHTAG_ENDIF='#endif'
    IDENTIFIER="regexp:[0-9]*[a-zA-Z_][a-zA-Z_0-9]*"
    VAR_IDENTIFIER="regexp:\$[a-zA-Z_][a-zA-Z_0-9]*"
    INTEGER="regexp:(([+\-])?[0-9]+)|(0x[0-9a-fA-F]+)|(0b[01]+)"
    BANG_OPERATOR="regexp:![a-zA-Z]+"
    BANG_COND="!cond"
    // Used by live preview only.
    WHITE_SPACE="regexp:\s*"
  ]

  extends(".*_type")=type
  extends(".*_body_item")=body_item
  extends(".*_value")=value
}

tableGenFile ::= (statement | include_directive | preprocessor_directive)*

// Fake base class referring to either body items or statements. Guaranteed to have a [TableGenIdentifierScopeNode] as
// parent, which is said to be the scope it is contained in.
fake scope_item ::=

statement ::= assert_statement
            | class_statement
            | def_statement
            | defm_statement
            | defset_statement
            | deftype_statement
            | defvar_statement
            | dump_statement
            | foreach_statement
            | if_statement
            | let_statement
            | multiclass_statement
            | BLOCK_COMMENT
            | LINE_COMMENT
            | OTHER {extends=scope_item}

include_directive ::= 'include' LINE_STRING_LITERAL {
    pin=1
    methods=[
        string="LINE_STRING_LITERAL"

        toString
        getIncludeSuffix
    ]
    implements=["com.github.zero9178.mlirods.language.psi.impl.TableGenIncludeDirectiveEx"
        "com.github.zero9178.mlirods.language.stubs.impl.TableGenIncludeDirectiveStubInterface"]
    stubClass="com.github.zero9178.mlirods.language.stubs.impl.TableGenIncludeDirectiveStub"
    mixin="com.github.zero9178.mlirods.language.psi.impl.TableGenIncludeDirectiveMixin"
    elementTypeClass="com.github.zero9178.mlirods.language.stubs.impl.TableGenIncludeDirectiveStubElementType"
}
preprocessor_directive ::= (HASHTAG_DEFINE | HASHTAG_IFDEF | HASHTAG_IFNDEF) IDENTIFIER
                         | HASHTAG_ENDIF | HASHTAG_ELSE
assert_statement ::= 'assert' value ',' value ';' {pin=1 extends=statement}

private equals_value ::= '=' value {pin=1}

// Fake base class for elements common among 'class' and 'multiclass' statements.
fake abstract_class_statement ::= template_arg_list? parent_class_list? '{'? '}'? {
    implements=[
        "com.github.zero9178.mlirods.language.psi.TableGenFoldingElement"
        "com.github.zero9178.mlirods.language.psi.TableGenIdentifierScopeNode"
    ]
    methods = [
        lAngle='LANGLE'
        rAngle='RANGLE'
        lBrace='LBRACE'
        rBrace='RBRACE'

        getPlaceHolderText
        getFoldingTextRanges
    ]
    extends=statement
}

class_statement ::= 'class' IDENTIFIER template_arg_list? record_body {
    extends=abstract_class_statement
    pin=1
}
private template_arg_list ::= '<' template_arg_decl (',' template_arg_decl)* '>' {pin=1}
template_arg_decl ::= type IDENTIFIER equals_value? {
    implements=[
        "com.github.zero9178.mlirods.language.psi.TableGenDefNameIdentifierOwner"
    ]
    methods=[
        nameIdentifier='IDENTIFIER'

        getName
        getTextOffset
    ]
}
private record_body ::= parent_class_list? body {pin=1}
parent_class_list ::= ':' class_ref (',' class_ref)* {pin=1}
class_ref ::= IDENTIFIER class_ref_suffix? {
    implements="com.github.zero9178.mlirods.language.psi.TableGenAngledFoldingElement"
    methods = [
        lAngle='LANGLE'
        rAngle='RANGLE'
    ]
}
private class_ref_suffix ::= '<' arg_value_list? '>' {pin=1}
private body ::= ';' | body_list
private body_list ::= '{' body_item* '}' {pin=1}

private body_recover ::= !('}' | 'field' | 'let' | 'defvar' | 'assert' | 'bit' | 'bits' | 'code' | 'dag' | 'int'
                       | 'list' | 'string' | IDENTIFIER)

body_item ::= field_body_item
            | let_body_item
            | defvar_body_item
            | assert_body_item
            {recoverWhile=body_recover extends=scope_item}
field_body_item ::= 'field'? type IDENTIFIER equals_value? ';' {
    implements="com.github.zero9178.mlirods.language.psi.TableGenFieldIdentifierNode"
    methods=[
        field_identifier="IDENTIFIER"
    ]
    pin=2
}
let_body_item ::= 'let' IDENTIFIER ('{' range_list '}')? '=' value ';' {
    pin=1
    implements="com.github.zero9178.mlirods.language.psi.TableGenFieldIdentifierNode"
    methods=[
        field_identifier="IDENTIFIER"
    ]
}
defvar_body_item ::= 'defvar' IDENTIFIER '=' value ';' {
    pin=1
    implements=[
        "com.github.zero9178.mlirods.language.psi.TableGenDefNameIdentifierOwner"
    ]
    methods=[
        nameIdentifier='IDENTIFIER'

        getName
        getTextOffset
    ]
}
private assert_body_item ::= assert_statement

def_statement ::= 'def' value? record_body {
    pin=1
    implements=[
        "com.github.zero9178.mlirods.language.psi.TableGenBracedFoldingElement"
        "com.github.zero9178.mlirods.language.psi.TableGenDefNameIdentifierOwner"
        "com.github.zero9178.mlirods.language.psi.TableGenIdentifierScopeNode"
    ]
    methods=[
        lBrace='LBRACE'
        rBrace='RBRACE'

        toString
        getName
        getNameIdentifier
        getTextOffset
        getPresentation
    ]
    stubClass="com.github.zero9178.mlirods.language.stubs.impl.TableGenDefNameIdentifierStub"
    elementTypeClass="com.github.zero9178.mlirods.language.stubs.impl.TableGenDefNameIdentifierStubElementType"
}
defm_statement ::= 'defm' value? parent_class_list? ';' {pin=1 extends=statement}
defset_statement ::= 'defset' type IDENTIFIER '=' '{' statement* '}' {pin=1 extends=statement}
deftype_statement ::= 'deftype' IDENTIFIER '=' type ';' {pin=1 extends=statement}
defvar_statement ::= 'defvar' IDENTIFIER '=' value ';' {
    pin=1
    implements=[
        "com.github.zero9178.mlirods.language.psi.TableGenDefNameIdentifierOwner"
    ]
    methods=[
        nameIdentifier='IDENTIFIER'

        toString
        getName
        getTextOffset
    ]
    stubClass="com.github.zero9178.mlirods.language.stubs.impl.TableGenDefNameIdentifierStub"
    elementTypeClass="com.github.zero9178.mlirods.language.stubs.impl.TableGenDefNameIdentifierStubElementType"
}
dump_statement ::= 'dump' value ';' {pin=1 extends=statement}

private statement_block ::= statement | statement_block_list
private statement_block_list ::= '{' statement* '}' {pin=1}

foreach_statement ::= 'foreach' foreach_iterator 'in' statement_block {
    pin=1
    implements=[
        "com.github.zero9178.mlirods.language.psi.TableGenBracedFoldingElement"
        "com.github.zero9178.mlirods.language.psi.TableGenIdentifierScopeNode"
    ]
    methods = [
        lBrace='LBRACE'
        rBrace='RBRACE'
    ]
    extends=statement
}
foreach_iterator ::= IDENTIFIER '=' ('{' range_list '}' | range_piece | value)

if_statement ::= 'if' value 'then' if_body else_body? {
    methods=[
        thenBody="if_body[0]"
        elseBody="if_body[1]"
    ]
    pin=1
    extends=statement
}
private else_body ::= 'else' if_body {pin=1}
if_body ::= statement_block {
    implements=[
        "com.github.zero9178.mlirods.language.psi.TableGenBracedFoldingElement"
        "com.github.zero9178.mlirods.language.psi.TableGenIdentifierScopeNode"
    ]
    methods = [
        lBrace='LBRACE'
        rBrace='RBRACE'
    ]
}

let_statement ::= 'let' let_list 'in' statement_block {
    pin=1
    implements=[
        "com.github.zero9178.mlirods.language.psi.TableGenBracedFoldingElement"
        "com.github.zero9178.mlirods.language.psi.TableGenIdentifierScopeNode"
    ]
    methods = [
        lBrace='LBRACE'
        rBrace='RBRACE'
    ]
    extends=statement
}
private let_list ::= let_item (',' let_item)*
let_item ::= IDENTIFIER ('<' range_list '>')? '=' value {
    implements="com.github.zero9178.mlirods.language.psi.TableGenFieldIdentifierNode"
    methods=[
        field_identifier="IDENTIFIER"
    ]
}
multiclass_statement ::= 'multiclass' IDENTIFIER template_arg_list? parent_class_list? statement_block {
    extends=abstract_class_statement
    pin=1
    extends=statement
}

type ::= bit_type
       | int_type
       | string_type
       | dag_type
       | code_type
       | bits_type
       | list_type
       | class_type
bit_type ::= 'bit'
int_type ::= 'int'
string_type ::= 'string'
dag_type ::= 'dag'
code_type ::= 'code'
bits_type ::= 'bits' '<' INTEGER '>' {pin=1}
list_type ::= 'list' '<' type '>' {pin=1}
class_type ::= IDENTIFIER

value ::= simple_value
        | field_access_value
        | bit_access_value
        | slice_access_value
        | concat_value

concat_value ::= value '#' value {pin=2}
field_access_value ::= value '.' IDENTIFIER {
    implements="com.github.zero9178.mlirods.language.psi.TableGenFieldIdentifierNode"
    methods=[
        field_identifier="IDENTIFIER"
    ]
    pin=2
}

bit_access_value ::= value '{' range_list '}' {pin=2}
private range_list ::= range_piece (',' range_piece)*
range_piece ::= bit_range
              | single_bit
single_bit ::= INTEGER {extends=range_piece}
bit_range ::= INTEGER ('...' | '-')? INTEGER {
    extends=range_piece
}

slice_access_value ::= value '[' slice_element (',' slice_element)* ']' {pin=2}
slice_element ::= slice_element_range
                | single_slice_element
single_slice_element ::= value {extends=slice_element}
slice_element_range ::= value ((('...' | '-') value) | INTEGER) {extends=slice_element}

private simple_value ::= integer_value
               | string_value
               | bool_value
               | undef_value
               | list_init_value
               | dag_init_value
               | class_instantiation_value
               | identifier_value
               | bang_operator_value
               | cond_operator_value

private value_list_ne ::= value (',' value)*

integer_value ::= INTEGER
string_value ::= block_string_value
               | LINE_STRING_LITERAL+
               | LINE_STRING_LITERAL_BAD
block_string_value ::= BLOCK_STRING_LITERAL {
    extends=string_value
    implements="com.github.zero9178.mlirods.language.psi.TableGenFoldingElement"
    methods = [
        getPlaceHolderText
    ]
}
bool_value ::= 'true' | 'false'
undef_value ::= '?'
list_init_value ::= '[' value_list_ne? ','? ']' ('<' type '>')? {pin=1}
dag_init_value ::= '(' dag_arg [dag_arg (',' dag_arg)*] ')' {
    pin=1
    methods=[
        operator="dag_arg[0]"
    ]
}
dag_arg ::= value (':' VAR_IDENTIFIER)? | VAR_IDENTIFIER
identifier_value ::= IDENTIFIER {
    methods=[
        getReference
    ]
}

class_instantiation_value ::= IDENTIFIER '<' arg_value_list? '>' {
    pin=2
    implements="com.github.zero9178.mlirods.language.psi.TableGenAngledFoldingElement"
    methods = [
        lAngle='LANGLE'
        rAngle='RANGLE'
    ]
}
// Note: This is a simplification from the official syntax that is easier to parse.
private arg_value_list ::= arg_value_item (',' arg_value_item)*
arg_value_item ::= value equals_value?

bang_operator_value ::= BANG_OPERATOR ('<' type '>')? '(' value_list_ne ')' {pin=1}
cond_operator_value ::= '!cond' '(' cond_clause (',' cond_clause)* ')' {pin=1}
cond_clause ::= value ':' value {
    methods=[
        condition="value[0]"
        thenValue="value[1]"
    ]
}
